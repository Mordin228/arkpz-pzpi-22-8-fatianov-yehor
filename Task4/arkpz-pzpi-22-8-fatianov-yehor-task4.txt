МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


Кафедра «Програмної інженерії»




ЗВІТ
З лабораторної роботи №4
з дисципліни
«Аналіз та рефакторинг коду»



Виконав:                                                                                                  Перевірив                      
ст. гр. ПЗПІ-22-8                                                                      ст. викладач каф. ПІ
Фатьянов Єгор                                                                                   Сокорчук І. П.












Харків 2024
4 РОЗРОБКА IoT КЛІЄНТА (БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ НАЛАШТУВАННЯ)

4.1	Мета роботи
Розробити програмне забезпечення для  IoT або SmartDevice пристрою, створеного на базі будь-якої поширеної на  сьогодні платформи, придатної для реалізації вбудованих систем (Embedded  System).
4.2	Хід роботи
4.2.1	Опис інженерних рішень
Для реалізації MedProtect було обрано мікроконтролер ESP32, що забезпечує ефективну роботу IoT-браслетів з можливістю передачі даних через Wi-Fi. Це рішення гарантує високу продуктивність, енергоефективність та підтримку MQTT-протоколу, що дозволяє передавати дані в реальному часі. IoT-браслет оснащений сенсором для моніторингу серцевого ритму, акселерометром для підрахунку кроків та OLED-дисплеєм для локального відображення показників. Wi-Fi модуль забезпечує зв’язок із сервером, передаючи дані у топік medprotect/health/data. Сервер обробляє отриману інформацію, аналізує її та у разі критичних показників надсилає сповіщення користувачеві або страховій компанії.
Обчислення кількості кроків здійснюється на основі даних акселерометра. Якщо прискорення по осі X перевищує порогове значення, система реєструє новий крок. Це дозволяє зменшити ймовірність хибного підрахунку та забезпечити точність даних. Витрачені калорії розраховуються за формулою, яка враховує кількість зроблених кроків і рівень фізичної активності, що визначається на основі серцевого ритму. Такий підхід дозволяє отримати більш точні значення, оскільки він враховує не лише механічну активність, а й рівень навантаження на організм.
Передача даних до сервера здійснюється за допомогою MQTT-протоколу, що забезпечує низьку затримку та стабільний зв’язок. Сервер аналізує показники та визначає, чи відповідають вони допустимим межам. Якщо виявлено перевищення критичних значень, система автоматично генерує сповіщення та записує подію в базу даних. У разі необхідності створюється запис про можливий страховий випадок для подальшої обробки менеджером.
Система забезпечує стабільну роботу завдяки безперервному моніторингу параметрів та циклічному оновленню даних. Всі вимірювання виконуються через певні інтервали часу, що дозволяє оптимізувати використання ресурсів. Такий підхід гарантує коректну обробку даних та можливість швидкого реагування на зміни стану користувача. Завдяки інтеграції MQTT, серверної обробки даних та ефективної взаємодії пристрою із сервером система є гнучкою, надійною та здатною до масштабування.




 
Рисунок 4.1 - Схема ІоТ пристрою програмної системи
4.2.2	Бізнес-логіка IoT клієнта
IoT клієнт MedProtect, заснований на ESP32, виконує роль персонального пристрою для моніторингу стану здоров’я користувача. Його основними завданнями є збір даних із сенсорів, передача показників на сервер та реагування на критичні зміни параметрів. Основні сенсори браслета включають датчик серцевого ритму та акселерометр для підрахунку кроків. Дані зчитуються із заданою періодичністю, обробляються локально і передаються через MQTT-протокол для подальшого аналізу.
Зчитування серцевого ритму відбувається в реальному часі, після чого дані нормалізуються та аналізуються. Якщо пульс перевищує встановлений поріг, система надсилає попередження на сервер, де приймається рішення про необхідність сповіщення користувача або страхової компанії. Кількість зроблених кроків визначається за допомогою акселерометра, який фіксує зміни прискорення та визначає повторювані рухи, характерні для ходьби. Калорії розраховуються на основі кроків та серцевого ритму, що дозволяє отримати більш точні результати, оскільки враховується рівень фізичного навантаження.
MQTT-протокол забезпечує двосторонній обмін даними. IoT клієнт публікує показники у визначені топіки, а сервер, у разі критичних змін, надсилає команди або сповіщення. Це дозволяє системі миттєво реагувати на зміни у стані користувача. Браслет також обладнаний OLED-дисплеєм, який відображає ключові показники в режимі реального часу. Щоб мінімізувати споживання енергії, оновлення дисплея відбувається лише у разі зміни параметрів або взаємодії з пристроєм.
Архітектура IoT клієнта базується на циклічній обробці даних. Всі сенсори опитуються із заданим інтервалом, після чого дані обробляються, передаються на сервер та виводяться на дисплей. У разі потреби сервер може надіслати команду активувати певні функції браслета, наприклад, вібросигнал для попередження користувача про критичний рівень серцевого ритму. Така схема дозволяє забезпечити автономну роботу пристрою та своєчасну реакцію на зміну фізичних показників користувача.



4.2.3	Створити UML діаграму прецедентів ІоТ клієнта
Структура бази даних MedProtect організована відповідно до реляційної моделі, що забезпечує зберігання та обробку даних про користувачів, IoT-пристрої, медичні показники та страхові випадки. Ключовою таблицею є Users, яка містить інформацію про користувачів системи, зокрема їхні персональні дані, електронну пошту, дату народження та зашифрований пароль. Це дозволяє системі ідентифікувати користувачів та забезпечити авторизацію.
Користувачі можуть мати прив’язані IoT-пристрої, що представлено у таблиці IoTDevices. Вона містить дані про серійний номер пристрою, час його активації та зв’язок із конкретним користувачем через зовнішній ключ. Ця структура дозволяє відстежувати, які пристрої використовуються кожним користувачем, і гарантує персоналізацію медичних показників.
Дані про стан здоров’я користувачів фіксуються у таблиці HealthMetrics. Вона містить показники серцевого ритму, кількість кроків і розрахунок витрачених калорій. Кожен запис прив’язаний до відповідного IoT-пристрою, що забезпечує безперервний моніторинг параметрів здоров’я користувача. У разі критичних змін параметрів система може згенерувати сповіщення або ініціювати відповідний страховий випадок.
Страхові події реєструються в таблиці InsuranceClaims, яка містить інформацію про статус випадку (наприклад, очікує розгляду, схвалено чи відхилено), дату подання заявки та суму страхового покриття. Таблиця пов’язана з користувачами через зовнішній ключ, що дозволяє відстежувати історію страхових виплат кожного клієнта.
Система також включає таблицю Notifications, яка відповідає за зберігання сповіщень для користувачів. Вона містить повідомлення про критичні зміни в показниках здоров’я, зокрема підвищений пульс або низьку активність. Кожне сповіщення прив’язане до конкретного користувача, що дозволяє ефективно інформувати його про можливі ризики.
Для управління адмініструванням системи створено таблицю Managers. Вона містить інформацію про менеджерів, які мають доступ до страхових випадків і можуть змінювати статус заявок. Таблиця містить рівні доступу, що забезпечує розмежування прав між адміністраторами та менеджерами страхових компаній.
Зв’язки між таблицями реалізовані через зовнішні ключі, що гарантує узгодженість даних і дозволяє легко масштабувати систему. Наприклад, один користувач може мати кілька IoT-пристроїв, кожен пристрій може генерувати численні медичні показники, а один користувач може мати декілька страхових випадків. Така модель бази даних забезпечує високу гнучкість системи, дозволяючи безперервний моніторинг стану здоров’я, своєчасну реакцію на критичні ситуації та ефективну взаємодію між користувачем, пристроєм та страховою компанією.


 
Рисунок 4.2 - UML діаграма прецедентів ІоТ клієнта
4.2.4	Створити UML діаграму діяльності ІоТ клієнта.

Цикл роботи IoT-клієнта побудований таким чином, щоб забезпечити постійний моніторинг параметрів середовища, обробку отриманих даних та автоматичне керування пристроями. На початковому етапі пристрій виконує підключення до WiFi, що забезпечує зв’язок із сервером. У разі успішного з’єднання відбувається підключення до MQTT брокера, після чого IoT-клієнт підписується на відповідні теми, що містять команди управління пристроями. Якщо підключення до мережі або MQTT не вдається, пристрій повторює спробу до моменту успішного з'єднання.
Після встановлення всіх необхідних з'єднань починається цикл моніторингу. IoT-клієнт послідовно зчитує значення температури, рівня кисню та pH. Отримані дані одразу передаються у відповідні MQTT-теми, де їх обробляє сервер. Паралельно з моніторингом сенсорів пристрій відстежує надходження команд через MQTT. Якщо сервер виявляє відхилення параметрів від норми, IoT-клієнт отримує команду на вмикання або вимикання відповідного пристрою: термостата для регулювання температури, аератора для підтримки рівня кисню або pH-контролера для стабілізації кислотності. Після виконання команди статус пристрою оновлюється у системі, а відповідні зміни відображаються на OLED-дисплеї.
Весь процес є циклічним: після завершення одного циклу сенсори опитуються знову, забезпечуючи безперервний моніторинг. Для збереження стабільності роботи встановлено фіксований інтервал у 5 секунд між циклами. Така організація дозволяє рівномірно оновлювати показники та уникати перевантаження системи.
Автоматизована робота IoT-клієнта мінімізує необхідність втручання користувача. Завдяки MQTT дані передаються на сервер миттєво, що забезпечує швидке реагування системи на будь-які зміни параметрів. OLED-дисплей дозволяє локально переглядати стан пристроїв і значення сенсорів у режимі реального часу. Гнучкість архітектури дозволяє легко інтегрувати додаткові сенсори та пристрої, забезпечуючи масштабованість системи. Організація циклічної роботи з чітко визначеними затримками дозволяє рівномірно контролювати параметри та підтримувати стабільність роботи IoT-клієнта.

 
Рисунок 4.3 - UML діаграма діяльності ІоТ клієнта.

4.4	Висновки

У ході роботи було створено програмну систему, яка забезпечує автоматичний моніторинг і управління параметрами середовища, використовуючи можливості платформи ESP32 та протоколу MQTT для обміну даними між пристроєм і сервером. IoT-клієнт виконує постійний контроль показників сенсорів, включаючи температуру, рівень кисню та pH, передаючи отримані дані на сервер для аналізу. На основі цих даних сервер приймає рішення про коригування параметрів і надсилає відповідні команди для керування пристроями, такими як термостат, аератор та pH-контролер. Після отримання команди IoT-клієнт змінює стан пристрою та синхронізує його зі світлодіодними індикаторами, що дозволяє оперативно контролювати роботу системи.
Завдяки циклічному алгоритму роботи клієнт безперервно контролює параметри та оперативно реагує на зміни, що мінімізує необхідність втручання користувача. Використання MQTT гарантує швидкий і стабільний обмін інформацією, забезпечуючи низьку затримку та ефективну взаємодію між сервером і пристроєм. Впроваджене рішення є надійним і масштабованим, що дозволяє легко інтегрувати нові сенсори та пристрої без значних змін у системі. Досягнуто автоматизації моніторингу, стабільного збереження та обробки отриманих даних, а також створено умови для подальшого розширення функціональності.
ДОДАТОК А
Програмний код ІоТ клієнта

1.  #include <WiFi.h>
2.  #include <PubSubClient.h>
3.  #include <Wire.h>
4.  #include <MPU6050.h>
5.  
6.  // WiFi параметры
7.  const char* ssid = "Wokwi-GUEST";
8.  const char* password = "";
9.  
10. // MQTT настройки
11. const char* mqtt_server = "broker.hivemq.com";
12. WiFiClient espClient;
13. PubSubClient client(espClient);
14.  
15. // Датчики
16. const int pulseSensorPin = 36; // VP (ADC1_CHANNEL_0)
17. MPU6050 mpu;
18.  
19. void reconnect() {
20.     while (!client.connected()) {
21.         Serial.print("⏳ Подключение к MQTT...");
22.         if (client.connect("ESP32Client")) {
23.             Serial.println("✅ Подключено!");
24.         } else {
25.             Serial.print("❌ Ошибка: ");
26.             Serial.println(client.state());
27.             delay(2000);
28.         }
29.     }
30. }
31.  
32. void setup() {
33.     Serial.begin(115200);
34.     Serial.println("\n🔄 Запуск ESP32...");
35.  
36.     pinMode(pulseSensorPin, INPUT);
37.  
38.     // Подключение к WiFi
39.     WiFi.begin(ssid, password);
40.     while (WiFi.status() != WL_CONNECTED) {
41.         delay(500);
42.         Serial.print(".");
43.     }
44.     Serial.println("\n✅ WiFi подключен!");
45.  
46.     // Подключение к MQTT
47.     client.setServer(mqtt_server, 1883);
48.     reconnect();
49.  
50.     // Подключение MPU6050
51.     Wire.begin();
52.     mpu.initialize();
53.  
54.     if (!mpu.testConnection()) {
55.         Serial.println("❌ Ошибка: MPU6050 не найден!");
56.     } else {
57.         Serial.println("✅ MPU6050 подключен!");
58.     }
59. }
60.  
61. void loop() {
62.     if (!client.connected()) {
63.         reconnect();
64.     }
65.  
66.     // Читаем потенциометр (эмулируем пульс)
67.     int sensorValue = analogRead(pulseSensorPin);
68.     int heartRate = map(sensorValue, 0, 4095, 60, 140);
69.  
70.     // Читаем шаги из MPU6050
71.     int16_t ax, ay, az;
72.     mpu.getAcceleration(&ax, &ay, &az);
73.  
74.     // Эмуляция шагов (если резкие изменения по X)
75.     static int steps = 0;
76.     if (abs(ax) > 8000) {
77.         steps++;
78.     }
79.  
80.     // Подсчет калорий (очень грубо: 1 шаг ≈ 0.05 кал)
81.     float caloriesBurned = steps * 0.05;
82.  
83.     // Вывод в Serial Monitor
84.     Serial.print("📊 Пульс: ");
85.     Serial.print(heartRate);
86.     Serial.print(" | Шаги: ");
87.     Serial.print(steps);
88.     Serial.print(" | Калории: ");
89.     Serial.println(caloriesBurned);
90.  
91.     // Отправка в MQTT
92.     String message = "{\"DeviceID\":1,\"HeartRate\":" + String(heartRate) +
93.                      ",\"Steps\":" + String(steps) +
94.                      ",\"CaloriesBurned\":" + String(caloriesBurned) + "}";
95.  
96.     client.publish("wokwi/device/1/data", message.c_str());
97.     Serial.println("📩 Данные отправлены: " + message);
98.  
99.     delay(20000);
100. }











ДОДАТОК Б
Серверна частина системи автоматизації та моніторингу IoT

1.  const express = require('express');
2.  const app = express();
3.  const bodyParser = require('body-parser');
4.  const mqtt = require('mqtt');
5.  const mysql = require('mysql2');
6.  
7.  // Налаштування бази даних MySQL
8.  const db = mysql.createConnection({
9.      host: 'localhost',
10.     user: 'root',
11.     password: 'password',
12.     database: 'iot_system'
13. });
14.  
15. db.connect((err) => {
16.     if (err) {
17.         console.error('❌ Помилка підключення до БД:', err);
18.         return;
19.     }
20.     console.log('✅ Підключено до бази даних');
21. });
22.  
23. // MQTT підключення
24. const mqttClient = mqtt.connect('mqtt://broker.hivemq.com');
25.  
26. mqttClient.on('connect', () => {
27.     console.log('✅ MQTT підключено');
28.     mqttClient.subscribe('wokwi/device/1/data');
29. });
30.  
31. mqttClient.on('message', (topic, message) => {
32.     console.log(`📩 Отримано MQTT повідомлення: ${message.toString()}`);
33.     try {
34.         const data = JSON.parse(message.toString());
35.         const { DeviceID, HeartRate, Steps, CaloriesBurned } = data;
36.         const query = 'INSERT INTO HealthMetrics (DeviceID, HeartRate, Steps, CaloriesBurned, Timestamp) VALUES (?, ?, ?, ?, NOW())';
37.         db.query(query, [DeviceID, HeartRate, Steps, CaloriesBurned], (err, result) => {
38.             if (err) {
39.                 console.error('❌ Помилка запису в БД:', err);
40.             } else {
41.                 console.log('✅ Дані збережено в БД');
42.             }
43.         });
44.     } catch (err) {
45.         console.error('❌ Помилка обробки MQTT повідомлення:', err);
46.     }
47. });
48.  
49. app.use(bodyParser.json());
50.  
51. // Отримати всі показники здоров'я
52. app.get('/api/health', (req, res) => {
53.     db.query('SELECT * FROM HealthMetrics ORDER BY Timestamp DESC', (err, results) => {
54.         if (err) {
55.             console.error('❌ Помилка отримання даних:', err);
56.             res.status(500).json({ error: 'Помилка отримання даних' });
57.         } else {
58.             res.json(results);
59.         }
60.     });
61. });
62.  
63. // Отримати дані за конкретним пристроєм
64. app.get('/api/health/:deviceID', (req, res) => {
65.     const deviceID = req.params.deviceID;
66.     db.query('SELECT * FROM HealthMetrics WHERE DeviceID = ? ORDER BY Timestamp DESC', [deviceID], (err, results) => {
67.         if (err) {
68.             console.error('❌ Помилка отримання даних:', err);
69.             res.status(500).json({ error: 'Помилка отримання даних' });
70.         } else {
71.             res.json(results);
72.         }
73.     });
74. });
75.  
76. // Запуск сервера
77. const PORT = process.env.PORT || 3000;
78. app.listen(PORT, () => {
79.     console.log(`✅ Сервер запущено на порту ${PORT}`);
80. });

Посилання на відео : https://youtu.be/_0XJ1GVkv8U

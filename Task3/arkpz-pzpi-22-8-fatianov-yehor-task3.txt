МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


Кафедра «Програмної інженерії»




ЗВІТ
З лабораторної роботи №3
з дисципліни
«Аналіз та рефакторинг коду»



Виконав:                                                                                                  Перевірив                      
ст. гр. ПЗПІ-22-8                                                                      ст. викладач каф. ПІ
Фатьянов Єгор                                                                                   Сокорчук І. П.












Харків 2024
3 РОЗРОБКА БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ АДМІНІСТРУВАННЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ

3.1	Мета роботи
Розробити бізнес-логіку та функції адміністрування серверної частини програмної системи, що призначена для проведення рекламної акції.
3.2	Хід роботи
3.2.1	Опис інженерних рішень
Система MedProtect побудована на клієнт-серверній архітектурі, яка забезпечує ефективну взаємодію між користувачами, IoT-пристроями та серверною частиною. Вона розроблена для збору, обробки та аналізу медичних показників, що надходять з носимих пристроїв (наприклад, IoT-браслетів), а також для управління страховими випадками та сповіщеннями про критичні зміни у здоров’ї користувачів.
Центральним компонентом системи виступає серверна частина, яка відповідає за обробку даних, реалізацію бізнес-логіки та забезпечення доступу до функціональності через REST API. Сервер працює на платформі ASP.NET Core, що забезпечує високу продуктивність, масштабованість та безпеку. Для зберігання даних використовується MS SQL Server, який гарантує ефективність роботи з великими обсягами інформації, а також підтримує транзакції для забезпечення цілісності даних.
Основними елементами архітектури є:
•	Бізнес-логіка, яка включає обробку отриманих з IoT-пристроїв даних про пульс, кількість пройдених кроків, витрачені калорії та інші параметри здоров’я. Вона також відповідає за виявлення критичних відхилень і автоматичне створення страхових випадків або сповіщень для користувачів та медичних служб.
•	Модуль адміністрування, який дозволяє страховим агентам керувати користувачами, перевіряти страхові випадки, аналізувати статистику та переглядати історію змін параметрів здоров’я.
•	REST API, який забезпечує зв’язок між сервером, мобільними додатками та веб-інтерфейсом. API дозволяє реєструвати користувачів, підключати IoT-пристрої, отримувати історичні дані та створювати страхові заявки.
Для комунікації IoT-пристроїв з сервером використовується протокол MQTT, який дозволяє в режимі реального часу передавати дані про стан здоров’я користувача. Це забезпечує швидке реагування на критичні ситуації, такі як аномально високий пульс або раптове зниження активності.
Безпека системи реалізована через:
•	Шифрування паролів за допомогою bcrypt.js, що запобігає компрометації облікових даних;
•	JWT-авторизацію для контролю доступу користувачів і страхових агентів;
•	Розмежування доступу залежно від ролі користувача (звичайний користувач, страховий агент, адміністратор);
•	Логування всіх важливих подій, включаючи зміни параметрів здоров’я та обробку страхових випадків.
Система MedProtect є масштабованою завдяки гнучкій архітектурі, яка дозволяє легко інтегрувати нові типи сенсорів або розширювати функціональність. База даних підтримує зберігання великих обсягів інформації, а серверна частина оптимізована для швидкої обробки запитів.
Завдяки автоматичному резервному копіюванню та можливості відстеження всіх змін у системі, MedProtect забезпечує високу надійність і захист даних користувачів. Інтерфейс для адміністраторів та страхових агентів доступний через веб-додаток або API, тоді як користувачі можуть взаємодіяти з системою через мобільний додаток, отримуючи миттєві сповіщення про свій стан здоров’я.
Обрані інженерні рішення гарантують стабільну роботу MedProtect, її ефективність та безпеку, роблячи систему гнучким і надійним інструментом для моніторингу здоров’я та страхового обслуговування.

3.2.2	Бізнес-логіка
Система MedProtect автоматизує моніторинг здоров'я користувачів, забезпечуючи своєчасне реагування на критичні зміни параметрів здоров'я та управління страховими випадками. Основна бізнес-логіка полягає у взаємодії між користувачем, IoT-пристроями та сервером для збору та аналізу даних, що дозволяє страхувальникам ефективно обробляти інформацію та приймати рішення щодо страхових виплат.
IoT-браслети зчитують дані про серцевий ритм, кількість кроків та витрачені калорії, передаючи їх на сервер через протокол MQTT. Серверна частина отримує ці показники, аналізує їх та порівнює із встановленими межами. Якщо показники виходять за безпечні значення (наприклад, серцевий ритм перевищує 120 ударів на хвилину), система автоматично надсилає повідомлення користувачу та заносить подію до журналу моніторингу. У критичних ситуаціях може створюватися страховий випадок, що потребує подальшого розгляду.
Після аналізу показників система зберігає оновлені значення у базі даних, дозволяючи користувачам переглядати свою історію здоров’я через мобільний додаток або веб-інтерфейс. Страхові агенти отримують доступ до детальної статистики користувачів та можуть приймати рішення щодо виплат на основі зібраних даних.
Для стабільної роботи системи використано кілька ключових алгоритмів:
Генерація випадкових значень для тестування
Під час симуляції даних на ESP32 використовується генерація випадкових коливань серцевого ритму та активності:
heartRate += random(-5, 5);
steps += random(0, 10);
Це дозволяє тестувати алгоритми аналізу даних у реальних умовах.
Перевірка меж значень (норми)
Сервер порівнює отримані значення з допустимими межами:
if (heartRate >= 60 && heartRate <= 100) {
    // Нормальний стан
} else {
    // Відхилення від норми, необхідне повідомлення або створення страхового випадку
}
Наприклад, якщо частота серцевих скорочень перевищує 120 ударів, система відправляє попередження.
Обчислення калорій на основі ЧСС та активності
Використовується формула, яка враховує частоту серцевих скорочень та рівень фізичної активності:
let caloriesBurned = (0.014 * heartRate + 0.035 * steps) * timeInMinutes;
Це дозволяє оцінювати рівень фізичної активності користувача.
Логування критичних подій
Якщо виявлено значні відхилення, запис додається до журналу:
INSERT INTO Notifications (UserID, NotificationDate, Message)
VALUES (${userID}, GETDATE(), '⚠ Високий пульс: ${heartRate} ударів/хв!');
Страхові агенти можуть використовувати ці записи для прийняття рішень.
Створення страхового випадку
Якщо показники виходять за критичні межі, система автоматично ініціює запит на розгляд страхового випадку:
INSERT INTO InsuranceClaims (UserID, ClaimDate, Status, PayoutAmount)
VALUES (${userID}, GETDATE(), 'Pending', NULL);
Це спрощує процес оформлення виплат та автоматизує взаємодію користувача зі страховою компанією.
Циклічне оновлення даних
IoT-пристрої передають дані кожні 10 секунд, використовуючи таймер:
if (millis() - lastUpdate > 10000) {
    lastUpdate = millis();
    sendDataToServer();
}
Це дозволяє забезпечити актуальність інформації.
MQTT-обробка команд
Сервер може надсилати команди IoT-пристроям, наприклад, для налаштування частоти відправки даних або активації режиму екстреного моніторингу:
if (message == "increase_frequency") {
    updateInterval = 5000; // Збільшити частоту оновлення
}
Це дозволяє реагувати на критичні ситуації в режимі реального часу.
Завдяки впровадженим механізмам система MedProtect забезпечує автоматизований моніторинг здоров’я, сповіщення про відхилення від норми, а також ефективне управління страховими випадками. Це дозволяє підвищити якість страхового обслуговування та швидкість реагування на потенційні загрози здоров’ю користувачів.

3.2.3	Розробка UML діаграми діяльності для серверної частини
Ініціалізація системи MedProtect починається із запуску серверного додатка, який забезпечує взаємодію між користувачами, IoT-браслетами та страховою компанією. Під час цього сервер підключається до бази даних MS SQL Server, де зберігається інформація про користувачів, їхні пристрої та показники здоров'я. Паралельно встановлюється з’єднання з MQTT-брокером, що забезпечує отримання даних із носимих пристроїв у режимі реального часу.
Після успішного підключення система завантажує маршрути REST API, які забезпечують доступ до функціоналу сервера. Вони дозволяють виконувати авторизацію користувачів, переглядати їхні показники здоров'я, реєструвати нові пристрої та обробляти страхові випадки.
Основний процес починається, коли IoT-браслет надсилає MQTT-повідомлення про серцевий ритм, кількість кроків та витрачені калорії. Сервер отримує ці дані, перевіряє їх на відповідність нормам та заносить до бази даних. Якщо показники виходять за межі допустимих значень (наприклад, частота серцевих скорочень перевищує 120 ударів за хвилину), система генерує сповіщення користувачеві та реєструє подію у журналі моніторингу.
У критичних випадках (наприклад, різке зниження серцевого ритму чи аномальна активність) система автоматично створює запит на страховий випадок для подальшого розгляду менеджерами. Інформація передається у відповідний модуль API, що дозволяє страховій компанії оперативно отримувати дані та приймати рішення щодо виплат.
Паралельно система обробляє REST-запити, які надходять до маршрутів API, зокрема:
•	/users – управління обліковими записами користувачів;
•	/devices – реєстрація та управління IoT-браслетами;
•	/metrics – перегляд історії показників здоров'я;
•	/claims – обробка страхових випадків.
Для аналізу здоров'я користувачів система може визначати тренди у змінах серцевого ритму чи активності, що дозволяє прогнозувати можливі ризики та пропонувати індивідуальні страхові пакети.
Всі події логуються у системі, що дозволяє адміністраторам та страховим агентам здійснювати ретроспективний аналіз даних та приймати обґрунтовані рішення щодо страхових виплат. Сервер виконує роль синхронізації між пристроями та базою даних, забезпечуючи точність та актуальність медичних показників.
На фінальному етапі сервер переходить у стан очікування, готовий до отримання нових MQTT-повідомлень від пристроїв або REST-запитів від користувачів. Така архітектура дозволяє системі працювати безперервно, адаптивно реагуючи на зміни в показниках здоров'я, підвищуючи ефективність страхового обслуговування та рівень медичної безпеки користувачів.

 
Рисунок 3.1 - UML діаграма діяльності для серверної частини
3.2.4	Розробка UML діаграми взаємодії для серверної частини
Система MedProtect забезпечує взаємодію між клієнтом, сервером, базою даних та IoT-пристроями для ефективного моніторингу здоров'я користувачів і обробки страхових випадків. Основний обмін даними здійснюється через REST API для взаємодії з користувачами та MQTT-протокол для зв’язку з IoT-браслетами.
Клієнтська частина, представлена у вигляді веб- або мобільного додатку, відправляє запити до серверу, які сервер обробляє, звертаючись до бази даних (MS SQL Server). Усі дані про користувачів, показники здоров'я, страхові випадки та сповіщення централізовано зберігаються у базі, що забезпечує їхню цілісність, швидкий доступ і захист. Після обробки запитів сервер повертає відповідь клієнту у вигляді результатів операцій або актуальних даних.
Система також інтегрована з MQTT-брокером, який забезпечує отримання даних із IoT-браслетів у реальному часі. Сервер приймає дані про серцевий ритм, кількість кроків та витрачені калорії, після чого аналізує їх та записує у базу даних. Якщо показник серцевого ритму виходить за допустимі межі, сервер формує сповіщення для користувача та може рекомендувати звернутися до лікаря.
У процесі роботи сервер виконує такі основні дії:
Аналізує отримані дані про здоров’я користувача.
При виявленні підвищеного серцевого ритму формує критичне повідомлення.
Оновлює та зберігає дані у базі для подальшого аналізу.
У разі потреби реєструє страхову подію та передає її менеджерам для розгляду.
Надсилає команди IoT-браслету через MQTT, наприклад, для нагадування про фізичну активність.
Після виконання кожної дії сервер надає доступ клієнту до актуальної інформації про стан здоров’я, історії показників та статусу страхових звернень. Завдяки інтеграції REST API та MQTT система MedProtect є надійною платформою, що забезпечує як моніторинг стану здоров’я в режимі реального часу, так і ефективну обробку страхових випадків.

 
Рисунок 3.2 - UML діаграма взаємодії для серверної частини

3.3	Висновки
У ході виконання роботи було розроблено бізнес-логіку та функції адміністрування серверної частини програмної системи MedProtect. Реалізовано взаємодію серверної частини з базою даних, що дозволяє зберігати та аналізувати інформацію про користувачів, їхні показники здоров'я та страхові випадки.
Налаштовано маршрути REST API, що забезпечують ефективну обробку запитів та управління даними, а також інтегровано MQTT-брокер для зв’язку з IoT-браслетами. Впроваджено алгоритми автоматичного аналізу показників здоров'я, що дозволяють своєчасно виявляти критичні відхилення та надсилати користувачам відповідні сповіщення.
Завдяки реалізованій системі адміністратори мають змогу контролювати страхові випадки, керувати користувачами та здійснювати аудит подій через систему логування. Прийняті технічні рішення гарантують надійну, безпечну та ефективну роботу системи MedProtect, що відповідає поставленим вимогам і сприяє покращенню процесу моніторингу здоров’я користувачів.












ДОДАТОК А
Адміністрування

Код контролера для управління користувачами

1. const express = require('express');
2. const router = express.Router();
3. const db = require('../config/db');
4. 
5. // Отримати всіх користувачів
6. router.get('/', async (req, res) => {
7.     try {
8.         const [users] = await db.query('SELECT * FROM Users');
9.         res.json({ success: true, users });
10.     } catch (error) {
11.         console.error('Error fetching users:', error);
12.         res.status(500).json({ success: false, error: error.message });
13.     }
14. });
15. 
16. // Отримати користувача за ID
17. router.get('/:id', async (req, res) => {
18.     const userId = req.params.id;
19.     try {
20.         const [user] = await db.query('SELECT * FROM Users WHERE UserID = ?', [userId]);
21.         if (user.length === 0) {
22.             return res.status(404).json({ success: false, message: 'User not found' });
23.         }
24.         res.json({ success: true, user: user[0] });
25.     } catch (error) {
26.         console.error('Error fetching user:', error);
27.         res.status(500).json({ success: false, error: error.message });
28.     }
29. });
30. 
31. module.exports = router;

Код контролера для управління IoT-пристроями

1. const express = require('express');
2. const router = express.Router();
3. const db = require('../config/db');
4. 
5. // Отримати всі IoT пристрої
6. router.get('/', async (req, res) => {
7.     try {
8.         const [devices] = await db.query('SELECT * FROM IoTDevices');
9.         res.json({ success: true, devices });
10.     } catch (error) {
11.         console.error('Error fetching IoT devices:', error);
12.         res.status(500).json({ success: false, error: error.message });
13.     }
14. });
15. 
16. // Прив’язати пристрій до користувача
17. router.put('/:id/assign', async (req, res) => {
18.     const deviceId = req.params.id;
19.     const { userId } = req.body;
20.     try {
21.         const [result] = await db.query(
22.             'UPDATE IoTDevices SET UserID = ? WHERE DeviceID = ?',
23.             [userId, deviceId]
24.         );
25. 
26.         if (result.affectedRows === 0) {
27.             return res.status(404).json({ success: false, message: 'Device not found' });
28.         }
29. 
30.         res.json({ success: true, message: 'Device assigned successfully' });
31.     } catch (error) {
32.         console.error('Error assigning device:', error);
33.         res.status(500).json({ success: false, error: error.message });
34.     }
35. });
36. 
37. module.exports = router;

Код контролера для управління показниками здоров'я

1. const express = require('express');
2. const router = express.Router();
3. const db = require('../config/db');
4. 
5. // Отримати всі показники здоров’я
6. router.get('/', async (req, res) => {
7.     try {
8.         const [metrics] = await db.query('SELECT * FROM HealthMetrics');
9.         res.json({ success: true, metrics });
10.     } catch (error) {
11.         console.error('Error fetching health metrics:', error);
12.         res.status(500).json({ success: false, error: error.message });
13.     }
14. });
15. 
16. // Додати новий показник здоров’я
17. router.post('/', async (req, res) => {
18.     const { deviceId, heartRate, steps, caloriesBurned } = req.body;
19.     try {
20.         const [result] = await db.query(
21.             'INSERT INTO HealthMetrics (DeviceID, HeartRate, Steps, CaloriesBurned) VALUES (?, ?, ?, ?)',
22.             [deviceId, heartRate, steps, caloriesBurned]
23.         );
24.         res.status(201).json({ success: true, message: 'Health metric added successfully', metricId: result.insertId });
25.     } catch (error) {
26.         console.error('Error adding health metric:', error);
27.         res.status(500).json({ success: false, error: error.message });
28.     }
29. });
30. 
31. module.exports = router;

Код контролера для управління страховими випадками

1. const express = require('express');
2. const router = express.Router();
3. const db = require('../config/db');
4. 
5. // Отримати всі страхові випадки
6. router.get('/', async (req, res) => {
7.     try {
8.         const [claims] = await db.query('SELECT * FROM InsuranceClaims');
9.         res.json({ success: true, claims });
10.     } catch (error) {
11.         console.error('Error fetching claims:', error);
12.         res.status(500).json({ success: false, error: error.message });
13.     }
14. });
15. 
16. // Додати страховий випадок
17. router.post('/', async (req, res) => {
18.     const { userId, status, payoutAmount } = req.body;
19.     try {
20.         const [result] = await db.query(
21.             'INSERT INTO InsuranceClaims (UserID, Status, PayoutAmount) VALUES (?, ?, ?)',
22.             [userId, status || 'Pending', payoutAmount]
23.         );
24.         res.status(201).json({ success: true, message: 'Claim added successfully', claimId: result.insertId });
25.     } catch (error) {
26.         console.error('Error adding claim:', error);
27.         res.status(500).json({ success: false, error: error.message });
28.     }
29. });
30. 
31. module.exports = router;

Посилання на відео : https://youtu.be/b6KUo8nfiZc
